<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# vers

```go
import "github.com/git-pkgs/vers"
```

Package vers provides version range parsing and comparison according to the VERS specification.

VERS \(Version Range Specification\) is a universal format for expressing version ranges across different package ecosystems. This package supports parsing vers URIs, native package manager syntax, and provides version comparison functionality.

Quick Start:

```
// Parse a vers URI
r, _ := vers.Parse("vers:npm/>=1.2.3|<2.0.0")
r.Contains("1.5.0") // true

// Parse native package manager syntax
r, _ = vers.ParseNative("^1.2.3", "npm")

// Check if version satisfies constraint
vers.Satisfies("1.5.0", ">=1.0.0,<2.0.0", "npm") // true

// Compare versions
vers.Compare("1.2.3", "1.2.4") // -1
```

See https://github.com/package-url/purl-spec/blob/main/VERSION-RANGE-SPEC.rst

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func Compare\(a, b string\) int](<#Compare>)
- [func CompareVersions\(a, b string\) int](<#CompareVersions>)
- [func CompareWithScheme\(a, b, scheme string\) int](<#CompareWithScheme>)
- [func Normalize\(version string\) \(string, error\)](<#Normalize>)
- [func Satisfies\(version, constraint, scheme string\) \(bool, error\)](<#Satisfies>)
- [func ToVersString\(r \*Range, scheme string\) string](<#ToVersString>)
- [func Valid\(version string\) bool](<#Valid>)
- [type Constraint](<#Constraint>)
  - [func ParseConstraint\(s string\) \(\*Constraint, error\)](<#ParseConstraint>)
  - [func \(c \*Constraint\) IsExclusion\(\) bool](<#Constraint.IsExclusion>)
  - [func \(c \*Constraint\) Satisfies\(version string\) bool](<#Constraint.Satisfies>)
  - [func \(c \*Constraint\) String\(\) string](<#Constraint.String>)
  - [func \(c \*Constraint\) ToInterval\(\) \(Interval, bool\)](<#Constraint.ToInterval>)
- [type Interval](<#Interval>)
  - [func EmptyInterval\(\) Interval](<#EmptyInterval>)
  - [func ExactInterval\(version string\) Interval](<#ExactInterval>)
  - [func GreaterThanInterval\(version string, inclusive bool\) Interval](<#GreaterThanInterval>)
  - [func LessThanInterval\(version string, inclusive bool\) Interval](<#LessThanInterval>)
  - [func NewInterval\(min, max string, minInclusive, maxInclusive bool\) Interval](<#NewInterval>)
  - [func UnboundedInterval\(\) Interval](<#UnboundedInterval>)
  - [func \(i Interval\) Adjacent\(other Interval\) bool](<#Interval.Adjacent>)
  - [func \(i Interval\) Contains\(version string\) bool](<#Interval.Contains>)
  - [func \(i Interval\) Intersect\(other Interval\) Interval](<#Interval.Intersect>)
  - [func \(i Interval\) IsEmpty\(\) bool](<#Interval.IsEmpty>)
  - [func \(i Interval\) IsUnbounded\(\) bool](<#Interval.IsUnbounded>)
  - [func \(i Interval\) Overlaps\(other Interval\) bool](<#Interval.Overlaps>)
  - [func \(i Interval\) String\(\) string](<#Interval.String>)
  - [func \(i Interval\) Union\(other Interval\) \*Interval](<#Interval.Union>)
- [type Parser](<#Parser>)
  - [func NewParser\(\) \*Parser](<#NewParser>)
  - [func \(p \*Parser\) Parse\(versURI string\) \(\*Range, error\)](<#Parser.Parse>)
  - [func \(p \*Parser\) ParseNative\(constraint string, scheme string\) \(\*Range, error\)](<#Parser.ParseNative>)
  - [func \(p \*Parser\) ToVersString\(r \*Range, scheme string\) string](<#Parser.ToVersString>)
- [type Range](<#Range>)
  - [func Empty\(\) \*Range](<#Empty>)
  - [func Exact\(version string\) \*Range](<#Exact>)
  - [func GreaterThan\(version string, inclusive bool\) \*Range](<#GreaterThan>)
  - [func LessThan\(version string, inclusive bool\) \*Range](<#LessThan>)
  - [func NewRange\(intervals \[\]Interval\) \*Range](<#NewRange>)
  - [func Parse\(versURI string\) \(\*Range, error\)](<#Parse>)
  - [func ParseNative\(constraint string, scheme string\) \(\*Range, error\)](<#ParseNative>)
  - [func Unbounded\(\) \*Range](<#Unbounded>)
  - [func \(r \*Range\) Contains\(version string\) bool](<#Range.Contains>)
  - [func \(r \*Range\) Exclude\(version string\) \*Range](<#Range.Exclude>)
  - [func \(r \*Range\) Intersect\(other \*Range\) \*Range](<#Range.Intersect>)
  - [func \(r \*Range\) IsEmpty\(\) bool](<#Range.IsEmpty>)
  - [func \(r \*Range\) IsUnbounded\(\) bool](<#Range.IsUnbounded>)
  - [func \(r \*Range\) String\(\) string](<#Range.String>)
  - [func \(r \*Range\) Union\(other \*Range\) \*Range](<#Range.Union>)
- [type VersionInfo](<#VersionInfo>)
  - [func ParseVersion\(s string\) \(\*VersionInfo, error\)](<#ParseVersion>)
  - [func \(v \*VersionInfo\) Compare\(other \*VersionInfo\) int](<#VersionInfo.Compare>)
  - [func \(v \*VersionInfo\) IncrementMajor\(\) \*VersionInfo](<#VersionInfo.IncrementMajor>)
  - [func \(v \*VersionInfo\) IncrementMinor\(\) \*VersionInfo](<#VersionInfo.IncrementMinor>)
  - [func \(v \*VersionInfo\) IncrementPatch\(\) \*VersionInfo](<#VersionInfo.IncrementPatch>)
  - [func \(v \*VersionInfo\) IsPrerelease\(\) bool](<#VersionInfo.IsPrerelease>)
  - [func \(v \*VersionInfo\) IsStable\(\) bool](<#VersionInfo.IsStable>)
  - [func \(v \*VersionInfo\) String\(\) string](<#VersionInfo.String>)


## Constants

<a name="Version"></a>Version is the library version.

```go
const Version = "0.1.0"
```

## Variables

<a name="SemanticVersionRegex"></a>SemanticVersionRegex matches semantic version strings.

```go
var SemanticVersionRegex = regexp.MustCompile(`^(\d+)(?:\.(\d+))?(?:\.(\d+))?(?:-([^+]+))?(?:\+(.+))?$`)
```

<a name="ValidOperators"></a>Valid constraint operators.

```go
var ValidOperators = []string{"=", "!=", "<", "<=", ">", ">="}
```

<a name="Compare"></a>
## func Compare

```go
func Compare(a, b string) int
```

Compare compares two version strings. Returns \-1 if a \< b, 0 if a == b, 1 if a \> b.

<a name="CompareVersions"></a>
## func CompareVersions

```go
func CompareVersions(a, b string) int
```

CompareVersions compares two version strings. Returns \-1 if a \< b, 0 if a == b, 1 if a \> b.

<a name="CompareWithScheme"></a>
## func CompareWithScheme

```go
func CompareWithScheme(a, b, scheme string) int
```

CompareWithScheme compares two version strings using scheme\-specific rules. Returns \-1 if a \< b, 0 if a == b, 1 if a \> b.

<a name="Normalize"></a>
## func Normalize

```go
func Normalize(version string) (string, error)
```

Normalize normalizes a version string to a consistent format.

<a name="Satisfies"></a>
## func Satisfies

```go
func Satisfies(version, constraint, scheme string) (bool, error)
```

Satisfies checks if a version satisfies a constraint.

If scheme is empty, constraint is parsed as a vers URI. Otherwise, constraint is parsed as native package manager syntax.

<a name="ToVersString"></a>
## func ToVersString

```go
func ToVersString(r *Range, scheme string) string
```

ToVersString converts a Range back to a vers URI string.

<a name="Valid"></a>
## func Valid

```go
func Valid(version string) bool
```

Valid checks if a version string is valid.

<a name="Constraint"></a>
## type Constraint

Constraint represents a single version constraint \(e.g., "\>=1.2.3"\).

```go
type Constraint struct {
    Operator string
    Version  string
}
```

<a name="ParseConstraint"></a>
### func ParseConstraint

```go
func ParseConstraint(s string) (*Constraint, error)
```

ParseConstraint parses a constraint string into a Constraint.

<a name="Constraint.IsExclusion"></a>
### func \(\*Constraint\) IsExclusion

```go
func (c *Constraint) IsExclusion() bool
```

IsExclusion returns true if this is an exclusion constraint \(\!=\).

<a name="Constraint.Satisfies"></a>
### func \(\*Constraint\) Satisfies

```go
func (c *Constraint) Satisfies(version string) bool
```

Satisfies checks if a version satisfies this constraint.

<a name="Constraint.String"></a>
### func \(\*Constraint\) String

```go
func (c *Constraint) String() string
```

String returns the constraint as a string.

<a name="Constraint.ToInterval"></a>
### func \(\*Constraint\) ToInterval

```go
func (c *Constraint) ToInterval() (Interval, bool)
```

ToInterval converts this constraint to an interval. Returns nil for exclusion constraints \(\!=\).

<a name="Interval"></a>
## type Interval

Interval represents a mathematical interval of versions. For example, \[1.0.0, 2.0.0\) represents versions from 1.0.0 \(inclusive\) to 2.0.0 \(exclusive\).

```go
type Interval struct {
    Min          string
    Max          string
    MinInclusive bool
    MaxInclusive bool
}
```

<a name="EmptyInterval"></a>
### func EmptyInterval

```go
func EmptyInterval() Interval
```

EmptyInterval creates an interval that matches no versions.

<a name="ExactInterval"></a>
### func ExactInterval

```go
func ExactInterval(version string) Interval
```

ExactInterval creates an interval that matches exactly one version.

<a name="GreaterThanInterval"></a>
### func GreaterThanInterval

```go
func GreaterThanInterval(version string, inclusive bool) Interval
```

GreaterThanInterval creates an interval for versions greater than the given version.

<a name="LessThanInterval"></a>
### func LessThanInterval

```go
func LessThanInterval(version string, inclusive bool) Interval
```

LessThanInterval creates an interval for versions less than the given version.

<a name="NewInterval"></a>
### func NewInterval

```go
func NewInterval(min, max string, minInclusive, maxInclusive bool) Interval
```

NewInterval creates a new interval with the given bounds.

<a name="UnboundedInterval"></a>
### func UnboundedInterval

```go
func UnboundedInterval() Interval
```

UnboundedInterval creates an interval that matches all versions.

<a name="Interval.Adjacent"></a>
### func \(Interval\) Adjacent

```go
func (i Interval) Adjacent(other Interval) bool
```

Adjacent returns true if the two intervals are adjacent \(can be merged\).

<a name="Interval.Contains"></a>
### func \(Interval\) Contains

```go
func (i Interval) Contains(version string) bool
```

Contains checks if the interval contains the given version.

<a name="Interval.Intersect"></a>
### func \(Interval\) Intersect

```go
func (i Interval) Intersect(other Interval) Interval
```

Intersect returns the intersection of two intervals.

<a name="Interval.IsEmpty"></a>
### func \(Interval\) IsEmpty

```go
func (i Interval) IsEmpty() bool
```

IsEmpty returns true if this interval matches no versions.

<a name="Interval.IsUnbounded"></a>
### func \(Interval\) IsUnbounded

```go
func (i Interval) IsUnbounded() bool
```

IsUnbounded returns true if this interval matches all versions.

<a name="Interval.Overlaps"></a>
### func \(Interval\) Overlaps

```go
func (i Interval) Overlaps(other Interval) bool
```

Overlaps returns true if the two intervals overlap.

<a name="Interval.String"></a>
### func \(Interval\) String

```go
func (i Interval) String() string
```

String returns a string representation of the interval.

<a name="Interval.Union"></a>
### func \(Interval\) Union

```go
func (i Interval) Union(other Interval) *Interval
```

Union returns the union of two intervals, or nil if they cannot be merged.

<a name="Parser"></a>
## type Parser

Parser handles parsing of vers URIs and native package manager syntax.

```go
type Parser struct{}
```

<a name="NewParser"></a>
### func NewParser

```go
func NewParser() *Parser
```

NewParser creates a new Parser.

<a name="Parser.Parse"></a>
### func \(\*Parser\) Parse

```go
func (p *Parser) Parse(versURI string) (*Range, error)
```

Parse parses a vers URI string into a Range.

<a name="Parser.ParseNative"></a>
### func \(\*Parser\) ParseNative

```go
func (p *Parser) ParseNative(constraint string, scheme string) (*Range, error)
```

ParseNative parses a native package manager version range into a Range.

<a name="Parser.ToVersString"></a>
### func \(\*Parser\) ToVersString

```go
func (p *Parser) ToVersString(r *Range, scheme string) string
```

ToVersString converts a Range back to a vers URI string.

<a name="Range"></a>
## type Range

Range represents a version range as a collection of intervals. Multiple intervals represent a union \(OR\) of ranges.

```go
type Range struct {
    Intervals  []Interval
    Exclusions []string // Versions to exclude (from != constraints)
    // RawConstraints stores the original constraints for VERS output (not merged)
    RawConstraints []Interval
}
```

<a name="Empty"></a>
### func Empty

```go
func Empty() *Range
```

Empty creates a range that matches no versions.

<a name="Exact"></a>
### func Exact

```go
func Exact(version string) *Range
```

Exact creates a range that matches only the specified version.

<a name="GreaterThan"></a>
### func GreaterThan

```go
func GreaterThan(version string, inclusive bool) *Range
```

GreaterThan creates a range for versions greater than \(or equal to\) the specified version.

<a name="LessThan"></a>
### func LessThan

```go
func LessThan(version string, inclusive bool) *Range
```

LessThan creates a range for versions less than \(or equal to\) the specified version.

<a name="NewRange"></a>
### func NewRange

```go
func NewRange(intervals []Interval) *Range
```

NewRange creates a new Range from intervals.

<a name="Parse"></a>
### func Parse

```go
func Parse(versURI string) (*Range, error)
```

Parse parses a vers URI string into a Range.

The vers URI format is: vers:\<scheme\>/\<constraints\> For example: vers:npm/\>=1.2.3|\<2.0.0

Use vers:\<scheme\>/\* for an unbounded range that matches all versions.

<a name="ParseNative"></a>
### func ParseNative

```go
func ParseNative(constraint string, scheme string) (*Range, error)
```

ParseNative parses a native package manager version range into a Range.

Supported schemes:

- npm: ^1.2.3, \~1.2.3, 1.2.3 \- 2.0.0, \>=1.0.0 \<2.0.0, ||
- gem/rubygems: \~\> 1.2, \>= 1.0, \< 2.0
- pypi: \>=1.0,\<2.0, \~=1.4.2, \!=1.5.0
- maven: \[1.0,2.0\), \(1.0,2.0\], \[1.0,\)
- nuget: \[1.0,2.0\), \(1.0,2.0\]
- cargo: ^1.2.3, \~1.2.3, \>=1.0.0, \<2.0.0
- go: \>=1.0.0, \<2.0.0
- deb/debian: \>= 1.0, \<\< 2.0
- rpm: \>= 1.0, \<= 2.0

<a name="Unbounded"></a>
### func Unbounded

```go
func Unbounded() *Range
```

Unbounded creates a range that matches all versions.

<a name="Range.Contains"></a>
### func \(\*Range\) Contains

```go
func (r *Range) Contains(version string) bool
```

Contains checks if the range contains the given version.

<a name="Range.Exclude"></a>
### func \(\*Range\) Exclude

```go
func (r *Range) Exclude(version string) *Range
```

Exclude returns a new Range that excludes the given version.

<a name="Range.Intersect"></a>
### func \(\*Range\) Intersect

```go
func (r *Range) Intersect(other *Range) *Range
```

Intersect returns a new Range that is the intersection of this range and another.

<a name="Range.IsEmpty"></a>
### func \(\*Range\) IsEmpty

```go
func (r *Range) IsEmpty() bool
```

IsEmpty returns true if this range matches no versions.

<a name="Range.IsUnbounded"></a>
### func \(\*Range\) IsUnbounded

```go
func (r *Range) IsUnbounded() bool
```

IsUnbounded returns true if this range matches all versions.

<a name="Range.String"></a>
### func \(\*Range\) String

```go
func (r *Range) String() string
```

String returns a string representation of the range.

<a name="Range.Union"></a>
### func \(\*Range\) Union

```go
func (r *Range) Union(other *Range) *Range
```

Union returns a new Range that is the union of this range and another.

<a name="VersionInfo"></a>
## type VersionInfo

VersionInfo represents a parsed version with its components.

```go
type VersionInfo struct {
    Major      int
    Minor      int
    Patch      int
    Prerelease string
    Build      string
    Original   string
}
```

<a name="ParseVersion"></a>
### func ParseVersion

```go
func ParseVersion(s string) (*VersionInfo, error)
```

ParseVersion parses a version string into its components.

<a name="VersionInfo.Compare"></a>
### func \(\*VersionInfo\) Compare

```go
func (v *VersionInfo) Compare(other *VersionInfo) int
```

Compare compares this version to another. Returns \-1 if v \< other, 0 if v == other, 1 if v \> other.

<a name="VersionInfo.IncrementMajor"></a>
### func \(\*VersionInfo\) IncrementMajor

```go
func (v *VersionInfo) IncrementMajor() *VersionInfo
```

IncrementMajor returns a new version with major incremented.

<a name="VersionInfo.IncrementMinor"></a>
### func \(\*VersionInfo\) IncrementMinor

```go
func (v *VersionInfo) IncrementMinor() *VersionInfo
```

IncrementMinor returns a new version with minor incremented.

<a name="VersionInfo.IncrementPatch"></a>
### func \(\*VersionInfo\) IncrementPatch

```go
func (v *VersionInfo) IncrementPatch() *VersionInfo
```

IncrementPatch returns a new version with patch incremented.

<a name="VersionInfo.IsPrerelease"></a>
### func \(\*VersionInfo\) IsPrerelease

```go
func (v *VersionInfo) IsPrerelease() bool
```

IsPrerelease returns true if this is a prerelease version.

<a name="VersionInfo.IsStable"></a>
### func \(\*VersionInfo\) IsStable

```go
func (v *VersionInfo) IsStable() bool
```

IsStable returns true if this is a stable release \(no prerelease\).

<a name="VersionInfo.String"></a>
### func \(\*VersionInfo\) String

```go
func (v *VersionInfo) String() string
```

String returns the normalized version string.

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
